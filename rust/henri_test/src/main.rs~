// extern crate henry;
use henry;
use std::io;

use jack;

fn main() {
    // let x: VecDeque<f64> = vec![0.0, 1.0, 2.0, 3.0];
    // let y: Vec<f64> = vec![0.0, 1.0, 2.0, 3.0];
    // let x: henry::Flow = henry::Flow::new(vec![0.0, 1.0, 2.0, 3.0]);
    // let y: henry::Flow = henry::Flow::new(Vec::<f64>::new());
    // let x = &mut henry::Flow::new(2);
    // let y = &mut henry::Flow::new(2);

    // let d: usize = 2;
    // let a: Box<[f64]> = Box::new([0.3, 0.5]);

    // println!("array {:#?}", a);

    // let x: f64 = 0.1_f64.cos();
    // let x = y * x;

    // println!("printing flow 1 {:#?}  and 2 {:#?}", x, y);

    // println!(
    //     "printing first elements flow 1 {:#?}  and 2 {:#?}",
    //     x[0], y[0]
    // );

    // x[0] = 1.1_f64;
    // y[0] = 1.2_f64;
    // y[1] = 3.4_f64;

    // println!(
    //     "printing first elements flow 1 {:#?}  and 2 {:#?}",
    //     x[0], y[0]
    // );

    // let x = x + y;

    // println!("printing flow 1 {:#?}  and 2 {:#?}", &x, &y);

    // let x = x + y;

    // println!("again printing flow 1 {:#?}  and 2 {:#?}", &x, &y);

    // let x = henry::Point { x: 2, y: 3 };
    // let y = henry::Point { x: 1, y: 0 };

    // println!("again printing point 1 {:#?}  and 2 {:#?}", x, y);

    // let x = x + y;

    // println!("again printing point 1 {:#?}  and 2 {:#?}", x, y);

    // let mut x = henry::State::new(2);
    // let mut y = henry::State::new(2);

    // x[0] = 1.2;
    // x[1] = 3.4;
    // y[0] = 5.6;
    // y[1] = 7.8;

    // println!("printing state 1 {:#?}  and 2 {:#?}", x, y);

    // let x = x + y;

    // println!("printing state 1 {:#?}  and 2 {:#?}", x, y);

    // let c: &Fn(f64) -> f64 = &|x: f64| -> f64 { x * 2.0_f64 };

    // let mut p = vec![c];

    // println!("calling p[0] {:#?}", p[0](4.1_f64));

    // let c = &|x: f64| -> f64 { x * 2.1_f64 };

    // p.push(c);

    // println!("calling p[0] {:#?}, {:#?}", p[0](4.1_f64), p[1](4.1_f64));
    let mut hen = henry::Henry::new(2, 2);

    let d = 5;
    // let mut p = henry::PhaseSpace::new(d);
    let mut p = hen.newphase();
    let mut i = 0;
    let a = &vec![1.0_f64; d];

    while i < d {
        println!("calling {} {:#?}", i, p.flow[i](a, i));
        i = i + 1;
    }

    // // let f1 = Box::new(|x: f64| -> f64 { x * 2.1_f64 });
    p.flow[4] = Box::new(|x: &[f64], i: usize| -> f64 { x[i] * -2.1_f64 });
    // // p.flow[4] = f1;

    println!("calling again =========");

    i = 0;
    while i < d {
        println!("calling {} {:#?}", i, p.flow[i](a, i));
        i = i + 1;
    }

    // p.flow[3] = f1;

    // // println!("calling again =========");

    // // i = 0;
    // // while i < d {
    // //     println!("calling {} {:#?}", i, p.f[i](1.0_f64));
    // //     i = i + 1;
    // // }

    p.newpath();
    // println!("inspecting state {:#?}", p.paths);
    p.paths[0][4] = 0.5_f64;
    println!("inspecting state {:#?}", p.paths);
    p.integrate();
    println!("inspecting state {:#?}", p.paths);

    let pp = &mut p;

    pp.integrate();
    println!("inspecting state {:#?}", pp.paths);

    pp.paths[0][4] = 0.5_f64;
    p.paths[0][4] = 0.5_f64;

    // // let v: Vec<Box<Fn(f64) -> f64>> = vec![Box::new(|x| 1.1_f64 * x)];
    // // vec![Box::new(|x| 1.1_f64 * x); 10];
    // // let v: Vec<i32> = (0..10).map(|i| i).collect();

    // // println!("inspect v {:#?}", v);

    // {
    //     Ok(_) => u16::from_str(&user_input.trim()).ok().map(|n| n as f64),
    //     Err(_) => None,
    // }

    // let (client, _status) =
    //     jack::Client::new("rust_henry", jack::ClientOptions::NO_START_SERVER).unwrap();

    // let mut out_port = client
    //     .register_port("sine_out", jack::AudioOut::default())
    //     .unwrap();

    // let mut frequency = 220.0;
    // let sample_rate = client.sample_rate();
    // let frame_t = 1.0 / sample_rate as f64;
    // let mut time = 0.0;

    // let process = jack::ClosureProcessHandler::new(
    //     move |_: &jack::Client, ps: &jack::ProcessScope| -> jack::Control {
    //         // Get output buffer
    //         let out = out_port.as_mut_slice(ps);

    //         // Write output
    //         for v in out.iter_mut() {
    //             let x = frequency * time * 2.0 * std::f64::consts::PI;
    //             let y = x.sin();
    //             *v = y as f32;
    //             time += frame_t;
    //         }

    //         // Continue as normal
    //         jack::Control::Continue
    //     },
    // );

    // // 4. activate the client
    // let active_client = client.activate_async((), process).unwrap();

    // let mut user_input = String::new();
    // io::stdin().read_line(&mut user_input);

    // let h = henry::Henry {
    //     chin: 2,
    //     chout: 2,
    //     process: Box::new(|input: &[f64], output: &mut [f64]| -> () { output[0] = 0.0_f64 }),
    // };

    // h.start();
}
