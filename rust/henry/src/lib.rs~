use std::io;

const DT: f64 = 1.0_f64 / (48_000_f64 * 2.0_f64);

pub struct PhaseSpace {
    pub flow: Vec<Box<Fn(&[f64], usize) -> f64>>,
    pub paths: Vec<Vec<f64>>,
    dim: usize,
    numpaths: usize,
}

impl PhaseSpace {
    pub fn new(d: usize) -> PhaseSpace
// where
    //     F: 'static + Send + FnMut(&jack::Client, &jack::ProcessScope) -> jack::Control,
    {
        let mut i = 0;
        let mut f: Vec<Box<Fn(&[f64], usize) -> f64>> = vec![];
        while i < d {
            f.push(Box::new(move |_x: &[f64], _i: usize| -> f64 { 0.0_f64 }));
            i = i + 1;
        }

        PhaseSpace {
            flow: f,
            paths: vec![],
            dim: d,
            numpaths: 0,
        }
    }

    pub fn newpath(&mut self) -> () {
        self.paths.push(vec![0.0_f64; self.dim]);
        self.numpaths = self.numpaths + 1;
    }

    pub fn integrate(&mut self) -> () {
        let mut i: usize = 0;
        let mut j: usize;
        let mut k: usize;
        while i < self.numpaths {
            j = 0;
            k = 0;
            while j < self.dim {
                println!("integrating for {}", j);
                self.paths[i][j] = self.paths[i][j] + self.flow[j](&self.paths[i], j) * DT;
                j = j + 1;
            }
            j = self.dim;
            while k < self.dim {
                j = j - 1;
                println!("integrating for {}", j);
                self.paths[i][j] = self.paths[i][j] + self.flow[j](&self.paths[i], j) * DT;
                k = k + 1;
            }
            i = i + 1;
        }
    }
}

pub struct Henry {
    pub chin: usize,
    pub chout: usize,
    pub process: Box<Fn(&[f64], &mut [f64]) -> ()>,
    phnum: usize,
    phsp: Vec<PhaseSpace>,
}

impl Henry {
    pub fn new(chin: usize, chout: usize) -> Henry {
        Henry {
            chin,
            chout,
            process: Box::new(|_i: &[f64], _o: &mut [f64]| -> () {}),
            phnum: 0,
            phsp: vec![],
        }
    }

    pub fn newphase(&mut self) -> &PhaseSpace {
        self.phsp.push(PhaseSpace::new(2));
        self.phnum = self.phnum + 1;
        return &self.phsp[self.phnum - 1];
    }

    pub fn start(&self) -> () {
        // set up jack
        let (client, _status) =
            jack::Client::new("rust_henry", jack::ClientOptions::NO_START_SERVER).unwrap();

        let client = client;

        let mut out_port = client
            .register_port("sine_out", jack::AudioOut::default())
            .unwrap();

        let process = jack::ClosureProcessHandler::new(
            move |_: &jack::Client, ps: &jack::ProcessScope| -> jack::Control {
                // Get output buffer
                let outb = out_port.as_mut_slice(ps);

                // Write output
                // for v in out.iter_mut() {
                //     let x = 220.0 * time * 2.0 * std::f64::consts::PI;
                //     let y = x.sin();
                //     *v = y as f32;
                //     time += 1.0 / 48000.0 as f64;;
                // }

                // Continue as normal
                jack::Control::Continue
            },
        );

        // activate the client
        let _active_client = client.activate_async((), process).unwrap();

        // block
        let mut user_input = String::new();
        io::stdin().read_line(&mut user_input);
    }
}
